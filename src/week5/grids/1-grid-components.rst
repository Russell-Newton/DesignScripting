===========================
Grasshopper Grid Components
===========================

The grid components in Grasshopper are a little different from what we're talking about
here. They can all be found under the Vector > Grid dropdown. Each of these components
have two outputs: ``Cells`` and ``Points``.

The biggest difference between the grid components and the vector-based grids we're
talking about is that the vector-based grids are generated as linear combinations
of basis vectors, but the Grasshopper component grids are generated by tiling the
geometry that connects the grid points (i.e.: the grid cells).

Square
======

.. admonition:: Corresponding Basis
    :class: seealso

    .. math::
        \begin{flalign}
        \mathbf{u} &= \mathtt{Size} \cdot \begin{bmatrix}
            1 & 0
        \end{bmatrix}&&\\
        \mathbf{v} &= \mathtt{Size} \cdot \begin{bmatrix}
            0 & 1
        \end{bmatrix}&&
        \end{flalign}

The Square grid component creates a grid tiled by squares. ``Points`` at ``{0;0;A}(B)``
is the point given by:

.. math::
    \mathtt{A}\mathbf{u} + \mathtt{B}\mathbf{v}

``Cells`` at ``{0;0;A}(B)`` is the square with ``Points`` at ``{0;0;A}(B)`` at its bottom-left
corner. As such, there is one less path in the ``Cells`` tree, and each list contains
one fewer item than the ``Points`` tree.

Rectangular
===========

.. admonition:: Corresponding Basis
    :class: seealso

    .. math::
        \begin{flalign}
        \mathbf{u} &= \mathtt{SizeX} \cdot \begin{bmatrix}
            1 & 0
        \end{bmatrix}&&\\
        \mathbf{v} &= \mathtt{SizeY} \cdot \begin{bmatrix}
            0 & 1
        \end{bmatrix}&&
        \end{flalign}

Rectangular is functionally the same as Square, but with different basis vectors.

Hexagonal
=========

.. admonition:: Corresponding Basis
    :class: seealso

    .. math::
        \begin{flalign}
        \mathbf{u} &= \mathtt{Size} \cdot \begin{bmatrix}
            \frac{3}{2} & \frac{\sqrt{3}}{2}
        \end{bmatrix}&&\\
        \mathbf{v} &= \mathtt{Size} \cdot \begin{bmatrix}
            0 & \sqrt{3}
        \end{bmatrix}&&
        \end{flalign}

The Hexagonal grid component creates a tiling of hexagons. ``Points`` at ``{0;0;A}(B)``
is given by:

.. math::

    \mathtt{A}\mathbf{u} + \left(\mathtt{B} - \left\lfloor\frac{\mathtt{A}}{2}\right\rfloor\right)\mathbf{v}

These points form the corners of a triangular grid. ``Cells`` at ``{0;0;A}(B)`` is the
hexagon centered at the point at ``Points`` at ``{0;0;A}(B)``.


Triangular
==========

.. admonition:: Corresponding Basis
    :class: seealso

    .. math::
        \begin{flalign}
        \mathbf{origin} &= \mathtt{Size} \cdot \begin{bmatrix}
            \frac{1}{2} & \frac{\sqrt{3}}{6}
        \end{bmatrix}&&\\
        \mathbf{u} &= \mathtt{Size} \cdot \begin{bmatrix}
            \frac{1}{2} & \frac{\sqrt{3}}{6}
        \end{bmatrix}&&\\
        \mathbf{v} &= \mathtt{Size} \cdot \begin{bmatrix}
            0 & \frac{\sqrt{3}}{3}
        \end{bmatrix}&&
        \end{flalign}

    In this case, :math:`\mathbf{origin}` is the centroid of ``Cells`` at ``{0;0;0}(0)``.
    All points in ``Points`` are shifted by this vector.

Triangular is slightly different because ``Points`` corresponds to the centroids of
each triangular grid cell. As such, not all grid points generated as linear combinations
of :math:`\mathbf{u}` and :math:`\mathbf{v}` will be present in ``Points``. Instead,
``Points`` at ``{0;0;A}(B)`` is given by:

.. math::
    \mathbf{origin} + \mathtt{A}\mathbf{u} + \begin{cases}
        \frac{3\mathtt{B} - \mathtt{A} + \left(\mathtt{B} \bmod 2\right)}{2}\mathbf{v} & \text{if } \mathtt{A} \text{ is even} \\
        \frac{3\mathtt{B} - \left(\mathtt{B} \bmod 2\right)}{2}\mathbf{v} & \text{if } \mathtt{A} \text{ is odd}
    \end{cases}

This is quite a weird setup, but it's how you could convert from the basis above
to the points given by ``Points``. These points form the corners of a hexagonal grid.
``Cells`` at ``{0;0;A}(B)`` is the triangle centered at ``Points`` at ``{0;0;A}(B)``.
Some of these will be "pointing down", while others will be "pointed up".

Radial
======

.. admonition:: Corresponding Basis
    :class: seealso

    .. math::
        \begin{flalign}
        \mathbf{origin} &= \begin{bmatrix}
            0 & 90^\circ
        \end{bmatrix}&&\\
        \mathbf{r} &= \mathtt{Size} \cdot \begin{bmatrix}
            1 & 0
        \end{bmatrix}&&\\
        \mathbf{p} &= \begin{bmatrix}
            0 & -\frac{360^\circ}{\mathtt{ExtentP}}
        \end{bmatrix}&&
        \end{flalign}

    :math:`\mathbf{origin}` in this case is set up such that the first point
    in each path of ``Points`` will be vertical, and iteration over the list
    at that path sweeps clockwise.

Radial is another weird one, where grid points are instead computed in radial
coordinates. Points in the grid can still be calculated as linear combinations of
the basis vectors (:math:`\mathbf{r}` and :math:`\mathbf{p}` in the case of polar
coordinates), with the first component of the point being the radius and the second
being the angle.

``Points`` at ``{0;0;A}(B)`` is given by:

.. math::

    \mathbf{origin} + \mathtt{A}\mathbf{r} + \mathtt{B}\mathbf{p}

``Cells`` at ``{0;0;A}(B)`` is the grid cell with corners given by ``Points`` at
``{0;0;A}(B)``, ``{0;0;A}(B + 1)``, ``{0;0;A + 1}(B + 1)``, and ``{0;0;A + 1}(B)``.

Use Cases
=========

The Square, Rectangular, and Radial components are very useful if you need an array of cells
and their corners on demand with minimal effort. The ``Points`` provided by Hexagonal
and Triangular though aren't as useful as the ``Cells`` themselves because you can get
the centroid of a polyline with the Area component.

Considering you can recreate each of these grids with Python manually, the best
use-case for these existing components is convenience, particularly when you want the
polyline cells they provide.
